<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on (p)retired</title>
    <link>https://pretired.dazwilkin.com/posts/</link>
    <description>Recent content in Posts on (p)retired</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 26 Sep 2019 00:00:00 -0700</lastBuildDate>
    
	<atom:link href="https://pretired.dazwilkin.com/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>PyPi Transparency</title>
      <link>https://pretired.dazwilkin.com/posts/190926/</link>
      <pubDate>Thu, 26 Sep 2019 00:00:00 -0700</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/190926/</guid>
      <description>I&amp;rsquo;ve been noodling around with another Trillian personality.
Another in a theme that interests me in providing tamperproof logs for the packages in the popular package management registries.
The Golang team recently announced Go Module Mirror which is built atop Trillian. It seems to me that all the package registries (Go Modules, npm, Maven, NuGet etc.) would benefit from tamperproof logs hosted by a trusted 3rd-party.
As you may have guessed, PyPi Transparency is a log for PyPi packages.</description>
    </item>
    
    <item>
      <title>Run cAdvisor when using Docker Compose</title>
      <link>https://pretired.dazwilkin.com/posts/190925/</link>
      <pubDate>Wed, 25 Sep 2019 00:00:00 -0700</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/190925/</guid>
      <description>cAdvisor has long been a favorite monitoring tool of mine. I&amp;rsquo;m using Docker Compose for local testing and have begun including a cAdvisor in my docker-compose.yaml files.
cadvisor: restart: always image: google/cadvisor:${CADVISOR_VERSION} container_name: cadvisor # command: # - --prometheus_endpoint=&amp;quot;/metrics&amp;quot; # Default volumes: - &amp;quot;/:/rootfs:ro&amp;quot; - &amp;quot;/var/run:/var/run:rw&amp;quot; - &amp;quot;/sys:/sys:ro&amp;quot; - &amp;quot;/var/snap/docker/current:/var/lib/docker:ro&amp;quot; #- &amp;quot;/var/lib/docker/:/var/lib/docker:ro&amp;quot; expose: - &amp;quot;8080&amp;quot; ports: - 8080:8080  I&amp;rsquo;d not realized until recently, that cAdvisor also surfaces a Prometheus metrics endpoint and so, if you do follow this path and you&amp;rsquo;re also using Prometheus, don&amp;rsquo;t forget to add cAdvisor to your Prometheus targets.</description>
    </item>
    
    <item>
      <title>Kubernetes Engine and Free Tier</title>
      <link>https://pretired.dazwilkin.com/posts/190924/</link>
      <pubDate>Tue, 24 Sep 2019 09:40:14 -0700</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/190924/</guid>
      <description>Google Cloud Platform Free Tier appears (please verify this for yourself) to provide the ability to run a(n admittedly miniscule) Kubernetes cluster for free. So, why do this? It provides a definitive Kubernetes (Engine) experience on Google Cloud Platform that you may use for learning and testing.
Kubernetes Engine the master node(s) and the control plane are free.
Kubernetes (i.e. Compute Engine) nodes potentially incur charges including for the VM runtime and any attached storage, snapshots etc.</description>
    </item>
    
    <item>
      <title>Cloud Functions Simple(st) HTTP Multi-host Proxy</title>
      <link>https://pretired.dazwilkin.com/posts/190918/</link>
      <pubDate>Wed, 18 Sep 2019 12:45:00 -0700</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/190918/</guid>
      <description>Tweaked yesterday&amp;rsquo;s solution so that it will randomly select one from several hosts with which it&amp;rsquo;s configured.
package proxy import ( &amp;quot;log&amp;quot; &amp;quot;math/rand&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;net/url&amp;quot; &amp;quot;os&amp;quot; &amp;quot;strings&amp;quot; &amp;quot;time&amp;quot; ) func robin() { hostsList := os.Getenv(&amp;quot;PROXY_HOST&amp;quot;) if hostsList == &amp;quot;&amp;quot; { log.Fatal(&amp;quot;&#39;PROXY_HOST&#39; environment variable should contain comma-separated list of hosts&amp;quot;) } // Comma-separated lists of hosts hosts := strings.Split(hostsList, &amp;quot;,&amp;quot;) urls := make([]*url.URL, len(hosts)) for i, host := range hosts { var origin = Endpoint{ Host: host, Port: os.</description>
    </item>
    
    <item>
      <title>Cloud Functions Simple(st) HTTP Proxy</title>
      <link>https://pretired.dazwilkin.com/posts/190917/</link>
      <pubDate>Tue, 17 Sep 2019 12:41:02 -0700</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/190917/</guid>
      <description>I&amp;rsquo;m investigating the use of LetsEncrypt for gRPC services. I found this straightforward post by Scott Devoid and am going to try this approach.
Before I can do that, I need to be able to publish services (make them Internet-accessible) and would like to try to continue to use GCP for free.
Some time ago, I wrote about using the excellent Microk8s on GCP. Using an f1-micro, I&amp;rsquo;m hoping (!</description>
    </item>
    
    <item>
      <title>Visual Studio Code: gopls and YAML</title>
      <link>https://pretired.dazwilkin.com/posts/190610/</link>
      <pubDate>Tue, 10 Sep 2019 10:23:00 -0700</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/190610/</guid>
      <description>The Go team is developing a Language Server Protocol [LSP] implementation) called gopls. Visual Studio Code (and others) support LSP. Other languages (e.g. Python have LSP implementations too). I&amp;rsquo;ve been using gopls for some time. It works (mostly) very well and replaces multiple, indepedent tools with two (gopls and delve).
My Visual Studio Code settings that include gopls is:
&amp;quot;go.autocompleteUnimportedPackages&amp;quot;: true, &amp;quot;go.useLanguageServer&amp;quot;: true, &amp;quot;[go]&amp;quot;: { &amp;quot;editor.snippetSuggestions&amp;quot;: &amp;quot;none&amp;quot;, &amp;quot;editor.formatOnSave&amp;quot;: true, &amp;quot;editor.codeActionsOnSave&amp;quot;: { &amp;quot;source.</description>
    </item>
    
    <item>
      <title>pypi-transparency</title>
      <link>https://pretired.dazwilkin.com/posts/190907/</link>
      <pubDate>Sat, 07 Sep 2019 13:07:44 -0700</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/190907/</guid>
      <description>The goal of pypi-transparency is very similar to the underlying motivation for the Golang team&amp;rsquo;s Checksum Database (also built with Trillian).
Even though, PyPi provides hashes of the content of packages it hosts, the developer must trust that PyPi&amp;rsquo;s data is consistent. One ambition with pypi-transparency is to provide a companion, tamperproof log of PyPi package files in order to provide a double-check of these hashes.
It is important to understand what this does (and does not) provide.</description>
    </item>
    
    <item>
      <title>Welcome</title>
      <link>https://pretired.dazwilkin.com/posts/190906/</link>
      <pubDate>Fri, 06 Sep 2019 13:54:49 -0700</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/190906/</guid>
      <description>Now that I&amp;rsquo;ve (p)retired from Google, I&amp;rsquo;m starting this blog and will no longer post stories to Medium.
As I concluded my time at Google, I wrapped up work on a Trillian prototype. As it remains Google&amp;rsquo;s IP, I&amp;rsquo;m not permitted to discuss it here.
I&amp;rsquo;ve begun work on another Trillian prototype for Python package transparency, informally pypi-transparency.</description>
    </item>
    
  </channel>
</rss>