<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on (p)retired</title>
    <link>https://pretired.dazwilkin.com/tags/rust/</link>
    <description>Recent content in Rust on (p)retired</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 08 Oct 2020 00:00:00 -0700</lastBuildDate><atom:link href="https://pretired.dazwilkin.com/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Deploying a Rust HTTP server to DigitalOcean App Platform</title>
      <link>https://pretired.dazwilkin.com/posts/201008/</link>
      <pubDate>Thu, 08 Oct 2020 00:00:00 -0700</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/201008/</guid>
      <description>DigitalOcean launched an App Platform with many Supported Languages and Frameworks. I used Golang first, then wondered how to use non-natively-supported languages, i.e. Rust.
The good news is that Docker is a supported framework and so, you can run pretty much anything.
Repo: https://github.com/DazWilkin/do-apps-rust
Rust I&amp;rsquo;m a Rust noob. I&amp;rsquo;m always receptive to feedback on improvements to the code. I looked to mirror the Golang example. I&amp;rsquo;m using rocket and rocket-prometheus for the first time:</description>
    </item>
    
    <item>
      <title>Minimizing WASM binaries</title>
      <link>https://pretired.dazwilkin.com/posts/200819/</link>
      <pubDate>Wed, 19 Aug 2020 00:00:00 -0700</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/200819/</guid>
      <description>I&amp;rsquo;ve spent time recently playing around with WebAssembly (WASM) and waPC. Rust and WASM were born at Mozilla and there&amp;rsquo;s a natural affinity with writing WASM binaries in Rust. In the WASM examples I&amp;rsquo;ve been using for WASM Transparency, waPC and MsgPack and waPC and Protobufs.
I&amp;rsquo;ve created 3 WASM binaries: complex.wasm, simplex.wasm and fabcar.wasm and each is about 2.5MB when:
cargo build --target=wasm32-unknown-unknown --release The Rust and WebAssembly book has an excellent section titled Shrinking .</description>
    </item>
    
    <item>
      <title>WASM Transparency</title>
      <link>https://pretired.dazwilkin.com/posts/200817/</link>
      <pubDate>Mon, 17 Aug 2020 00:00:00 -0700</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/200817/</guid>
      <description>I&amp;rsquo;ve been playing around with a proof-of-concept combining WASM and Trillian. The hypothesis was to explore using WASM as a form of chaincode with Trillian. The project works but it&amp;rsquo;s far from being a chaincode-like solution.
Let&amp;rsquo;s start with a couple of (trivial) examples and then I&amp;rsquo;ll explain what&amp;rsquo;s going on and how it&amp;rsquo;s implemented.
2020/08/14 18:42:17 [main:loop:dynamic-invoke] Method: mul 2020/08/14 18:42:17 [random:New] Message 2020/08/14 18:42:17 [random:New] Float32 2020/08/14 18:42:17 [random:New] Float32 2020/08/14 18:42:17 [random:New] Message 2020/08/14 18:42:17 [random:New] Float32 2020/08/14 18:42:17 [random:New] Float32 2020/08/14 18:42:17 [Client:Invoke] Metadata: complex.</description>
    </item>
    
    <item>
      <title>waPC and MsgPack (Rust|Golang)</title>
      <link>https://pretired.dazwilkin.com/posts/200807/</link>
      <pubDate>Fri, 07 Aug 2020 00:00:00 -0700</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/200807/</guid>
      <description>As my reader will know (Hey Mom!), I&amp;rsquo;ve been noodling around with WASM and waPC. I&amp;rsquo;ve been exploring ways to pass structured messages across the host:guest boundary.
Protobufs was my first choice. @KevinHoffman created waPC and waSCC and he explained to me and that wSCC uses Message Pack.
It&amp;rsquo;s slightly surprising to me (still) that technologies like this exist with everyone else seemingly using them and I&amp;rsquo;ve not heard of them.</description>
    </item>
    
    <item>
      <title>Envoy WASM filters in Rust</title>
      <link>https://pretired.dazwilkin.com/posts/200723/</link>
      <pubDate>Thu, 23 Jul 2020 00:00:00 -0700</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/200723/</guid>
      <description>A digression thanks to Sal Rashid who&amp;rsquo;s exploring WASM filters w/ Envoy.
The documentation is sparse but:
 How to write WASM filters for Envoy&amp;hellip;  There is a Rust SDK but it&amp;rsquo;s not documented:
 proxy-wasm-rust-sdk  I found two useful posts by Rustaceans who were able to make use of it:
 Extending Envoy with WASM and Rust Extending Istio with Rust and WebAssembly  Here&amp;rsquo;s my simple use of the SDK&amp;rsquo;s examples.</description>
    </item>
    
    <item>
      <title>Rust implementation of Crate Transparency using Google Trillian</title>
      <link>https://pretired.dazwilkin.com/posts/200429/</link>
      <pubDate>Wed, 29 Apr 2020 00:00:00 -0800</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/200429/</guid>
      <description>I&amp;rsquo;ve been hacking on a Rust-based transparent application for Google Trillian. As appears to be my fixation, this personality is for another package manager. This time, Rust&amp;rsquo;s Crates often found in crates.io which is Rust&amp;rsquo;s Package Registry. I discussed this project earlier this month Rust Crate Transparency &amp;amp;&amp;amp; Rust SDK for Google Trillian and and earlier approach for Python&amp;rsquo;s packages with pypi-transparency.
This time, of course, I&amp;rsquo;m using Rust. And, by way of a first for me, for the gRPC server implementation (aka &amp;ldquo;personality&amp;rdquo;).</description>
    </item>
    
    <item>
      <title>Rust Crate Transparency &amp;&amp; Rust SDK for Google Trillian</title>
      <link>https://pretired.dazwilkin.com/posts/200403/</link>
      <pubDate>Fri, 03 Apr 2020 00:00:00 -0800</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/200403/</guid>
      <description>I&amp;rsquo;m noodling the utility of a Transparency solution for Rust Crates. When developers push crates to Cargo, a bunch of metadata is associated with the crate. E.g. protobuf. As with Golang Modules, Python packages on PyPi etc., there appears to be utility in making tamperproof recordings of these publications. Then, other developers may confirm that a crate pulled from cates.io is highly unlikely to have been changed.
On Linux, Cargo stores downloaded crates under ${HOME}/.</description>
    </item>
    
    <item>
      <title>gRPC, Cloud Run &amp; Endpoints</title>
      <link>https://pretired.dazwilkin.com/posts/200325/</link>
      <pubDate>Wed, 25 Mar 2020 00:00:00 -0800</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/200325/</guid>
      <description>&amp;lt;3 Google but there&amp;rsquo;s quite often an assumption that we&amp;rsquo;re all sitting around the engineering table and, of course, we&amp;rsquo;re not.
Cloud Endpoints is a powerful offering but &amp;ndash; IMO &amp;ndash; it&amp;rsquo;s super confusing to understand and complex to deploy.
If you&amp;rsquo;re familiar with the motivations behind service meshes (e.g. Istio), Cloud Endpoints fits in a similar niche (&amp;ldquo;neesh&amp;rdquo; or &amp;ldquo;nitch&amp;rdquo;?). The underlying ambition is that, developers can take existing code and by adding a proxy (or sidecar), general-purpose abstractions, security, logging etc.</description>
    </item>
    
    <item>
      <title>OriginStamp Rust SDK Example</title>
      <link>https://pretired.dazwilkin.com/posts/200312/</link>
      <pubDate>Thu, 12 Mar 2020 00:00:00 -0800</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/200312/</guid>
      <description>I wrote recently describing Python and Golang clients for OriginStamp based on OriginStamp&amp;rsquo;s API&amp;rsquo;s swagger spec. As a way to pursue learning rust, I&amp;rsquo;ve been forcing myself to write examples using rust. I&amp;rsquo;m honestly finding learning rust tough going and think I&amp;rsquo;m probably better to revert to the &amp;ldquo;Learning Rust&amp;rdquo; tutorials.
That said, herewith an explanation of building a rust client using an OpenAPI (!) generated SDK from OriginStamp&amp;rsquo;s swagger spec.</description>
    </item>
    
    <item>
      <title>PyPi Transparency Client (Rust)</title>
      <link>https://pretired.dazwilkin.com/posts/190930/</link>
      <pubDate>Mon, 30 Sep 2019 00:00:00 -0700</pubDate>
      
      <guid>https://pretired.dazwilkin.com/posts/190930/</guid>
      <description>I&amp;rsquo;ve finally being able to hack my way through to a working Rust gRPC client (for PyPi Transparency).
It&amp;rsquo;s not very good: poorly structured, hacky etc. but it serves the purpose of giving me a foothold into Rust development so that I can evolve it as I learn the language and its practices.
There are several Rust crates (SDK) for gRPC. There&amp;rsquo;s no sanctioned SDK for Rust on grpc.io.
I chose stepancheg&amp;rsquo;s grpc-rust because it&amp;rsquo;s a pure Rust implementation (not built atop the C implementation).</description>
    </item>
    
  </channel>
</rss>
