<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on (p)retired</title>
    <link>https://pretired.dazwilkin.com/tags/python/</link>
    <description>Recent content in Python on (p)retired</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 11 Aug 2024 00:00:00 -0700</lastBuildDate>
    <atom:link href="https://pretired.dazwilkin.com/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>XML-RPC in Rust and Python</title>
      <link>https://pretired.dazwilkin.com/posts/240811/</link>
      <pubDate>Sun, 11 Aug 2024 00:00:00 -0700</pubDate>
      <guid>https://pretired.dazwilkin.com/posts/240811/</guid>
      <description>A lazy Sunday afternoon and my interest was piqued by XML-RPC&#xA;Client A very basic XML-RPC client wrapped in a Cloud Functions function:&#xA;main.py:&#xA;import functions_framework import os import xmlrpc.client endpoint = os.get_env(&amp;#34;ENDPOINT&amp;#34;) proxy = xmlrpc.client.ServerProxy(endpoint) @functions_framework.http def add(request): print(request) rqst = request.get_json(silent=True) resp = proxy.add( {&amp;#34;x&amp;#34;:{ &amp;#34;real&amp;#34;:rqst[&amp;#34;x&amp;#34;][&amp;#34;real&amp;#34;], &amp;#34;imag&amp;#34;:rqst[&amp;#34;x&amp;#34;][&amp;#34;imag&amp;#34;] }, &amp;#34;y&amp;#34;:{ &amp;#34;real&amp;#34;:rqst[&amp;#34;y&amp;#34;][&amp;#34;real&amp;#34;], &amp;#34;imag&amp;#34;:rqst[&amp;#34;y&amp;#34;][&amp;#34;imag&amp;#34;] } }) return resp requirements.txt:&#xA;functions-framework==3.* Run it:&#xA;python3 -m venv venv source venv/bin/activate python3 -m pip install --requirement requirements.</description>
    </item>
    <item>
      <title>Prost! Tonic w/ a dash of JSON</title>
      <link>https://pretired.dazwilkin.com/posts/240325/</link>
      <pubDate>Mon, 25 Mar 2024 00:00:00 -0700</pubDate>
      <guid>https://pretired.dazwilkin.com/posts/240325/</guid>
      <description>I naively (!) began exploring JSON marshaling of Protobufs in rust. Other protobuf language SDKs include JSON marshaling making the process straightforward. I was to learn that, in rust, it&amp;rsquo;s not so simple. Unfortunately, for me, this continues to discourage my further use of rust (rust is just hard).&#xA;My goal was to marshal an arbitrary protocol buffer message that included a oneof feature. I was unable to JSON marshal the rust generated by tonic for such a message.</description>
    </item>
    <item>
      <title>Kubernetes Python SDK w/ CRDs</title>
      <link>https://pretired.dazwilkin.com/posts/230708/</link>
      <pubDate>Sat, 08 Jul 2023 00:00:00 -0700</pubDate>
      <guid>https://pretired.dazwilkin.com/posts/230708/</guid>
      <description>Responded to Get Custom K8s Resource using Python and found the CustomObjectsApi documentation unclear.&#xA;If you have a cluster and a kubeconfig file with a correctly configured current-context, so that you can successfully:&#xA;PLURAL=&amp;#34;checks&amp;#34; kubectl get ${PLURAL} \ --all-namespaces NOTE I&amp;rsquo;m using Ackal&amp;rsquo;s CRDs in these examples.&#xA;Then you can use the following code to access the cluster&amp;rsquo;s REST API server to enumerate its CRDs:&#xA;main.py:&#xA;from __future__ import print_function from kubernetes import client, config from kubernetes.</description>
    </item>
    <item>
      <title>Python Protobuf changes</title>
      <link>https://pretired.dazwilkin.com/posts/230607/</link>
      <pubDate>Wed, 07 Jun 2023 00:00:00 -0700</pubDate>
      <guid>https://pretired.dazwilkin.com/posts/230607/</guid>
      <description>Python&amp;rsquo;s Protocol Buffers code-generation using protoc has had significant changes that can cause developers&amp;hellip; &amp;ldquo;challenges&amp;rdquo;. This post summarizes my experience of these mostly to save me from repreatedly recreating this history for myself when I forget it.&#xA;Version change Generated code change Implementation Backends I&amp;rsquo;ll use this summarized table of proto and the Pypi library&amp;rsquo;s history in this post. protoc refers to the compiler that supports code-generation in multiple languages. protobuf refers to the corresponding Python (runtime) library on Pypi:</description>
    </item>
    <item>
      <title>Programmatically deploying Cloud Run services (Golang|Python)</title>
      <link>https://pretired.dazwilkin.com/posts/210316/</link>
      <pubDate>Tue, 16 Mar 2021 00:00:00 -0700</pubDate>
      <guid>https://pretired.dazwilkin.com/posts/210316/</guid>
      <description>Phew! Programmitcally deploying Cloud Run services should be easy but it didn&amp;rsquo;t find it so.&#xA;My issues were that the Cloud Run Admin (!) API is poorly documented and it uses non-standard endpoints (thanks Sal!). Here, for others who may struggle with this, is how I got this to work.&#xA;Goal Programmatically (have Golang, Python, want Rust) deploy services to Cloud Run.&#xA;i.e. achieve this:&#xA;gcloud run deploy ${NAME} \ --image=${IMAGE} \ --platform=managed \ --no-allow-unauthenticated \ --region=${REGION} \ --project=${PROJECT} TRICK --log-http is your friend</description>
    </item>
    <item>
      <title>OriginStamp Python|Golang SDK Examples</title>
      <link>https://pretired.dazwilkin.com/posts/200217/</link>
      <pubDate>Mon, 17 Feb 2020 00:00:00 -0800</pubDate>
      <guid>https://pretired.dazwilkin.com/posts/200217/</guid>
      <description>A friend mentioned OriginStamp to me.&#xA;NB There are 2 sites: originstamp.com and originstamp.org.&#xA;It&amp;rsquo;s an interesting project.&#xA;It&amp;rsquo;s a solution for providing auditable proof that you had a(ccess to) some digital thing before a certain date. OriginStamp provides user-|developer-friendly means to submit files|hashes (of your content) and have these bundled into transactions that are submitted to e.g. bitcoin.&#xA;I won&amp;rsquo;t attempt to duplicate the narrative here, review OriginStamp&amp;rsquo;s site and some of its content.</description>
    </item>
    <item>
      <title>PyPi Transparency</title>
      <link>https://pretired.dazwilkin.com/posts/190926/</link>
      <pubDate>Thu, 26 Sep 2019 00:00:00 -0700</pubDate>
      <guid>https://pretired.dazwilkin.com/posts/190926/</guid>
      <description>I&amp;rsquo;ve been noodling around with another Trillian personality.&#xA;Another in a theme that interests me in providing tamperproof logs for the packages in the popular package management registries.&#xA;The Golang team recently announced Go Module Mirror which is built atop Trillian. It seems to me that all the package registries (Go Modules, npm, Maven, NuGet etc.) would benefit from tamperproof logs hosted by a trusted 3rd-party.&#xA;As you may have guessed, PyPi Transparency is a log for PyPi packages.</description>
    </item>
  </channel>
</rss>
